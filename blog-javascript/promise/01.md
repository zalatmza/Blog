# 实现Promise

## 一、简单版实现
### 基本用法
```js
const promise = new Promise((resolve, reject) => {
  if (xxx) {
    resolve()
  } else {
    reject()
  }
})

promise.then(a => {},e => {})
```

### 实现
```js
class Promise {
  value = undefined
  status = 'pending'
  
  successCb = () => null
  errorCb = () => null
  
  constructor (execCb) {
    const resolve = (value) => {
      if (this.status !== 'pending') { return }
      this.status = 'resolved'
      this.value = value
      // 这里是为了让successCb在promise.then后执行，用settimeout模拟
      setTimeout(() => {
        this.successCb(this.value)
      }, 0)
    }
    
    const reject = (error) => {
      if (this.status !== 'pending') { return }
      this.status = 'rejected'
      setTimeout(() => {
        this.errorCb(error)
      }, 0)
    }
    
    try {
      execCb(resolve, reject)
    } catch (e) {
      reject(e)
    }
  }
  
  then (resolveCb, rejectCb) {
    this.successCb = resolveCb
    this.errorCb = rejectCb
  }
}
```

### 测试
```js
const promise = new Promise((resolve, reject) => {
  console.log(1)
  resolve('resolve')
  console.log(2)
})

promise.then(a => {
  console.log(a)
}, e => {
  console.log(e)
})
```

输出
```
1
2
resolve
```

## 二、基本版实现
> 简单版不支持链式调用，链式调用是promise的核心，比较容易想到就是在then里 return new Promise

### 基本用法
```js
promise.then(a => {}).then(b => {})
```
### 实现
#### 1.改进then方法
```js
then (resolveCb, rejectCb) {
    this.successCbs.push(resolveCb)
    this.errorCbs.push(rejectCb)

    return new MyPromise((_resolve, _reject) => {
      try {
        _resolve()
      } catch (_error) {
        _reject(_error)
      }
    })
  }
```

##### 测试
```js
const promise = new MyPromise((resolve, reject) => {
  resolve('resolve')
})

promise.then(a => {
  console.log(a)
}).then(a => {
  console.log(a)
}) 
// resolve, undefined

promise.then(a => {
  console.log(a)
  return new Promise((a1, b1) => {
    a1(123)
  })
}).then(a => {
  console.log(a)
})
// resolve, undefined
```

> 第二个测试例子里，显然不符合我们的预期，我们需要对then返回的promise类型进行进一步判断

#### 2.增加对Promise的判断