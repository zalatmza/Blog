# 实现Promise

## 一、简单版实现
### 基本用法
```js
const promise = new Promise((resolve, reject) => {
  if (xxx) {
    resolve()
  } else {
    reject()
  }
})

promise.then(a => {},e => {})
```

### 实现
```js
const isFunction = func => typeof func === 'function'

class Promise {
  value = undefined
  status = 'pending'
  
  successCb = () => null
  errorCb = () => null
  
  resolve (value) {
    if (this.status !== 'pending') { return }
    this.status = 'resolved'
    this.value = value
    // 这里是为了让successCb在promise.then后执行，用settimeout模拟
    setTimeout(() => {
      let cb = () => null
      while ((cb = this.successCbs.shift())) {
        cb(this.value)
      }
    }, 0)
  }
  
  reject (error) {
    if (this.status !== 'pending') { return }
    this.status = 'rejected'
    this.value = error
    setTimeout(() => {
      let cb = () => null
      while ((cb = this.errorCbs.shift())) {
        cb(error)
      }
    }, 0)
  }
  
  constructor (execCb) {
    try {
      execCb(this.resolve, this.reject)
    } catch (e) {
      this.reject(e)
    }
  }
  
  then (resolveCb, rejectCb) {
    this.successCb = resolveCb
    this.errorCb = rejectCb
  }
}
```

##### 测试
```js
const promise = new Promise((resolve, reject) => {
  console.log(1)
  resolve('resolve')
  console.log(2)
})

promise.then(a => {
  console.log(a)
}, e => {
  console.log(e)
})
```

输出
```
1
2
resolve
```

## 二、基本版实现
> 简单版不支持链式调用，链式调用是promise的核心，比较容易想到就是在then里 return new Promise

### 基本用法
```js
promise.then(a => {}).then(b => {})
```
### 实现
#### 1.改进then方法
```js
constructor (execCb) {
  try {
    // this会因为execCb作用域改变，所以这里需要bind
    execCb(this.resolve.bind(this), this.reject.bind(this))
  } catch (e) {
    this.reject(e)
  }
}
  
then (resolveCb, rejectCb) {
  if (this.status === 'pending') {
    this.successCbs.push(resolveCb)
    this.errorCbs.push(rejectCb)
  }

  // 如果当前状态是 resolved 或者 rejected，直接执行
  if (this.status === 'resolved') {
    resolveCb(this.value)
  }

  if (this.status === 'rejected') {
    rejectCb(this.value)
  }

  return new Promise((_resolve, _reject) => {
    try {
      _resolve()
    } catch (_error) {
      _reject(_error)
    }
  })
}
```

##### 测试
```js
const promise = new Promise((resolve, reject) => {
  resolve('resolve')
})

// 例子1
promise.then(123).then(a => {
  console.log(a)
}) // Error

// 例子2
promise.then(a => {
  console.log(a)
  return new Promise((a1, b1) => {
    a1(123)
  })
}).then(a => {
  console.log(a)
}) // resolve, undefined
```
> 第一个测试例子里，没有对回调是非function时的处理

> 第二个测试例子里，显然不符合我们的预期，我们需要对then返回的promise类型进行进一步判断

#### 2.继续完善
```js
then (resolveCb, rejectCb) {
  const _this = this
  return new MyPromise((_resolve, _reject) => {
    // 重新封装resolveCb，因为resolveCb不一定是函数
    const execResolveCb = value => {
      if (!isFunction(resolveCb)) {
        _resolve(_this.value)
      } else {
        const res = resolveCb(value)
        if (res instanceof MyPromise) {
          // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
          res.then(_resolve, _reject)
        } else {
          // 否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
          _resolve(res)
        }
      }
    }

    const execRejectCb = value => {
      if (!isFunction(rejectCb)) {
        _reject(_this.value)
      } else {
        const res = rejectCb(value)
        if (res instanceof MyPromise) {
          // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
          res.then(_resolve, _reject)
        } else {
          // 否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
          _reject(res)
        }
      }
    }

    if (_this.status === 'pending') {
      _this.successCbs.push(execResolveCb)
      _this.errorCbs.push(execRejectCb)
    }

    if (_this.status === 'resolved') {
      execResolveCb(_this.value)
    }

    if (_this.status === 'rejected') {
      execRejectCb(_this.value)
    }
  })
}
```
##### 测试
```js
promise.then(12).then(console.log) // resolve

promise.then(a => new MyPromise((resolve, reject) => {
    setTimeout(() => {
      resolve('1')
    }, 1000)
  })
).then(console.log) // 1s之后输出：1
```
#### 3.继续补充
> 这里还有一种特殊的情况，就是当 resolve 方法传入的参数为一个 Promise 对象时，则该 Promise 对象状态决定当前 Promise 对象的状态。


## 参考
* [Promise实现原理（附源码）](https://juejin.im/post/5b83cb5ae51d4538cc3ec354)